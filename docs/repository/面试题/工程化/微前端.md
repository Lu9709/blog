# 微前端

## 什么是微前端

微前端是一种将前端应用拆分成更小、更独立的部分，以便于团队协作和维护的架构模式，每个微应用都可以独立开发，测试，部署和运行。

## 方案选型

### qiankun

qiankun 是一款基于 **single-spa** 的微前端框架，其核心原理是通过路由动态加载、隔离和运行子应用，实现多技术栈应用的集成与协同。以下是其核心原理的分解：

#### 原理

<br>

##### 子应用加载机制(HTML Entry)

qiankun 采用 **HTML Entry** 模式（区别于 single-spa 的 JS Entry），通过解析子应用的入口 HTML 文件获取资源：
1. **解析 HTML**
   * 使用 `import-html-entry` 包请求子应用的 HTML 入口文件，提取其中的 `JS`、`CSS` 和内联脚本/样式。
   * 返回结构化的资源信息：`template`（HTML 模板）、`scripts`（JS 文件）、`styles`（CSS 文件）和 `execScripts`（执行脚本的函数）
2. **动态加载与执行**
   * 通过 `execScripts()` 在沙箱环境中执行子应用的 JS 代码，并获取其导出的生命周期函数（`bootstrap`, `mount`, `unmount`）。
   * 调用 `bootstrap` 函数进行子应用的初始化。
   * 调用 `mount` 函数将子应用挂载到指定的容器中。
   * 调用 `unmount` 函数卸载子应用。

##### 隔离机制：JS与CSS沙箱

1. **JS 沙箱（运行时隔离）**
   * **Proxy 沙箱（主流方案）**
     - 基于 `Proxy` 代理全局对象（如 `window`），生成一个假的 `fakeWindow`。
     - 子应用对全局变量的读写操作均被拦截到 `fakeWindow`，避免污染主应用环境
   * **快照沙箱（兼容老旧浏览器）**
     - 在子应用加载前记录全局状态，卸载时还原快照，实现状态隔离。
2. **CSS 样式隔离**
   * **Scoped CSS**
     - 自动为子应用的样式添加唯一前缀（如 `data-qiankun="app-name"`），限制样式作用域。
   * **Shadow DOM（严格隔离）**
     - 通过 `attachShadow` API 将子应用的 DOM 和样式封装在独立作用域内（需配置 `strictStyleIsolation`）

##### 生命周期与路由管理

1. **生命周期钩子**
   * 子应用需导出标准生命周期函数（`bootstrap`, `mount`, `unmount`）。
   * qiankun 封装这些钩子，在路由切换时自动触发：
     * `bootstrap` 阶段：子应用加载完成，初始化完成。
     * `mount` 阶段：渲染 HTML → 挂载沙箱 → 执行子应用 mount()24。
     * `unmount` 阶段：调用子应用卸载 → 清理沙箱 → 移除 DOM4。
1. **路由劫持**
   * 主应用监听 `popstate` 等路由事件，根据 `activeRule` 规则匹配当前应激活的子应用。

##### 应用间通信机制

1. **Props 传递**
   * 主应用通过 `props` 向子应用传递数据或方法（如全局配置）。
2. **自定义事件**
   * 基于 `EventBus` 实现跨应用事件订阅与发布。
3. **全局状态管理**
   * 支持共享 Redux 或 Vuex 等状态库，或使用 qiankun 内置的 `initGlobalState` 管理共享状态。


#### 实现

现在使用 `vue3`、`vite`、`qiankun` 来实现微前端，但貌似 `qiankun` 不支持 `vite`。

因为 `vite` 的模块加载方式是 `esm`，而 `qiankun` 并不支持 `module script` 标签内解析 `esm` 格式的代码，导致子应用无法正确加载。

所以需要使用到 `vite-plugin-qiankun` （目前仓库只读）


### single-spa

single-spa 主应用通过路由匹配实现对子应用生命周期的管理

* 不支持 JS 沙箱隔离
* 不支持 CSS 隔离


## Why not iframe

为什么不使用 `iframe` 的问题是经常被讨论的。

`iframe` 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js隔离这类问题都能解决。

但他最大问题在于他的隔离性无法被突破，导致应用间的上下文无法被共享，会带来开发体验、产品体验的问题。

1. **URL与路由不同步**：浏览器提供刷新或前进/后退操作可能导致 `iframe` 的路由状态丢失，需要通过 `history.replaceState` 手动同步URL。

2. **UI不一致性**：`iframe` 内弹窗或遮罩层难以与主应用UI协调一致。

3. **上下文完全隔离导致共享困难**：

    * **通讯繁琐**：需要依赖 `window.postMessage` 实现跨域通信.

    * **状态同步问题**：主应用的 `cookie` 要**透传**到根域名都不同的子应用中实现免登效果。

    * **内存冗余**：每个 iframe 需要独立加载资源，增加内存消耗

#### 参考链接

> [qiankun - 乾坤](https://qiankun.umijs.org/zh/guide)
> 
> [可能是你见过最完善的微前端解决方案 - 知乎](https://zhuanlan.zhihu.com/p/78362028)
>
> [微前端的核心价值 - 知乎](https://zhuanlan.zhihu.com/p/95085796)
>
> [微前端五大门派 - 知乎](https://juejin.cn/post/7338230967390224435#heading-46)