# 数组去重

1. 使用计数排序的思路，缺点是只支持字符串

```javascript
var uniq = function (a) {
  var map = {}
  for (let i = 0; i < a.length; i++) {
    let number = a[i]
    if (typeof number === 'undefined') { continue }
    if (number in map) { continue }
    map[number] = true
  }
  const result = []
  for(let key in map) {
    result.push(parseInt(key))
  }
  return result
}
```

2. 使用Set（面试已经禁止这种了，因为太简单）

```javascript
// 写法1
var uniq = function (a) {
  return Array.from(new Set(a))
}
// 写法2
var uniq = function (a) {
  return [...new Set(a)]
}
```

3. 使用Map，缺点是兼容性差了

```javascript
var uniq = function (a) {
  var map = new Map()
  for(let i = 0; i < a.length; i++) {
    let number = a[i]
    if (typeof number === 'undefined') { continue }
    if (map.has(number)) { continue }
    map.set(number, true)
  }
  return [...map.keys()]
}
```

```javascript
/**
 * @description 数组去重，指定对应key
 */
var uniq = function (arr, key)  {
  return [...new Map(arr.map(item => [item[key], item])).values()];
}
```

4. `reduce` + `include`

```javascript
var uniq = function (arr) {
  return arr.reduce((pre, cur) => {
    return pre.include(cur) ? pre : [...pre, cur]
  }, [])
} 
```

5. `filter` + `indexOf`

只保留第一次出现的值，所以只要是第二次出现的，就会被筛掉，这能确保结果不会有重复的。

```js
function uniq(arr) {
  // indexOf 会回传在这个 array 等同于此值第一个 item 的 index，
  // 所以如果 indexOf 回传的 index 相等于目前 filter 到的值，
  // 则代表该值是第一次出现，我们保留起来，
  // 反之，如果 index 不等于，则代表此 array 中前面位置已经出现过，所以就 filter 掉。
  return arr.filter((item, index, array) => array.indexOf(item) === index)
}
```
6. 双层 for loop

```js
// 第一层 for loop，i 从 index 0 开始，到 arr 最后
  for (let i = 0, len = arr.length; i < len; i++) {
    // 第二层 for loop，j 从 i + 1 开始，要检查值是否重复
    for (let j = i + 1; j < len; j++) {
      // 如果值重复，则透过 splice 方法将 j 位置的值从 arr 去除
      if (arr[i] == arr[j]) {
        arr.splice(j, 1);
        // 移除重复的值之后，arr length 长度会需要减 1
        len--;
        // j 位置的值被移除，因此 j index 也要减 1
        j--;
      }
    }
  }
  return arr;
```