# 基于物理的渲染和照明

### 什么是基于物理的渲染 (PBR)？

**定义**：PBR 是一种使用真实世界物理定律来计算光线如何与物体表面相互作用的渲染技术。


### 启用物理上正确的光照

Three.js 提供了一个简单的开关来开启物理正确的光照计算，这对于实现PBR至关重要。

* **操作**：将渲染器的 `physicallyCorrectLights` 属性设置为 `true`。
* **作用**：启用后，Three.js 会使用真实的物理方程来**计算光线的衰减**（即光如何随着与光源距离的增加而减弱），这比默认的简单衰减模型更准确。

```js
function createRenderer() {
  const renderer = new WebGLRenderer();
  // 启用物理正确的光照
  renderer.physicallyCorrectLights = true;
  return renderer;
}
```

### 构建物理尺寸的场景

要使物理正确的光照生效，场景的尺寸必须符合现实世界的比例。

**单位约定**：在 Three.js 中，**1 个单位 = 1 米**。例如，一个边长为2的立方体，其真实尺寸是2米 x 2米 x 2米。

**重要性**：如果你的场景尺寸是随意设定的（比如一个“房间”有1000公里宽），那么使用真实灯泡的物理参数将毫无意义，因为光照计算是基于真实比例的。

**结论**：为了获得物理上准确的照明效果，必须将场景中的物体按真实世界的米制单位来建模。

### Three.js 中的光照类型

three.js 中的灯光类分为两种类型：

1. **直接光照** (Direct Lighting)：模拟从光源直接照射到物体的光线。Three.js 提供了四种直接光源：
   - `DirectionalLight`：模拟太阳光等遥远光源，光线是平行的。
   - `PointLight`：模拟灯泡，光线从一个点向四周发散。
   - `RectAreaLight`：模拟长条形灯或明亮的窗户。
   - `SpotLight`：模拟聚光灯，有锥形的光照范围。
2. **环境光** (Ambient Light)：一种简单、低成本的间接光照模拟方式。它均匀地照亮场景中的所有物体，模拟光线在环境中多次反弹后的效果。
3. **阴影**：默认情况下，Three.js 中的对象不会投射或接收阴影。阴影是计算成本很高的功能，需要手动为光源和接收阴影的物体分别启用。
   - 为光源启用阴影：将光源的 `castShadow` 属性设置为 `true`。
   - 为接收阴影的物体启用阴影：将物体的 `receiveShadow` 属性设置为 `true`。

### 实践添加DirectionalLight

基于之前的 World 类，添加物理正确的光照。

`DirectionalLight` 的光线不会随着距离而消失。**场景中的所有对象都将被同样明亮地照亮，无论它们放在哪里——即使是在灯光后面**。

1. **创建光源**：指定其颜色和强度。
2. **定位光源**：`DirectionalLight` 从其 `position` 照向其 `target.position`。默认目标是场景中心 (0, 0, 0)。通过修改 `light.position.set(x, y, z)` 可以改变光照方向。
3. **添加到场景**：在 `World.js` 中使用 `scene.add(light)` 将光源添加到场景中。

:::code-group 
```js [createLights.js]
import { DirectionalLight } from 'three';
function createLights() {
  // 创建一个强度为 8 的纯白光
  const light =  new DirectionalLight('white', 8);
  // // 从左上前方照射 灯光从(10,10,10)照向(0,0,0)。
  light.position.set(10, 10, 10); 
  return light;
}
export { createLights };
```
```js {3,17,19} [World.js]
import { createCamera } from './components/camera.js';
import { createCube } from './components/cube.js';
import { createLights } from './components/lights.js';
import { createScene } from './components/scene.js';

import { createRenderer } from './systems/renderer.js';
import { Resizer } from './systems/Resizer.js';
...
class World {
constructor(container) {
  camera = createCamera();
  scene = createScene();
  renderer = createRenderer();
  container.append(renderer.domElement);

  const cube = createCube();
  const light = createLights();

  scene.add(cube, light);

  const resizer = new Resizer(container, camera, renderer);
}
```
:::


### 切换基于物理的MeshStandardMaterial

* `MeshBasicMaterial`：最基本的材质，不受光照影响，整个表面是单一颜色，看起来像二维的。
* `MeshStandardMaterial`：这是 Three.js 中推荐的“标准”材质。它是一种高质量、物理上精确的材质，能对场景中的光照做出真实的反应。

`MeshBasicMaterial` 并且 `MeshStandardMaterial` 不是唯一可用的材料。three.js 核心中共有十八种材质，任何名称中带有“mesh”字样的材质都可以和立方体网格一起使用


**操作**：
1. 导入 `MeshStandardMaterial` 类
2. 用 `new MeshStandardMaterial()` 替换 `new MeshBasicMaterial()`。
3. 可以通过传入一个参数对象来设置材质属性，例如颜色。
   ```js
   const material = new MeshStandardMaterial({ color: "purple" });
   ```
4. 旋转立方体，使其看起来更加立体。
    ```js
    cube.rotation.set(-0.5, -0.1, 0.8);
    ```
