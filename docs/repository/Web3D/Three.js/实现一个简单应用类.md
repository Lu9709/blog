# 实现一个简单应用类

> 对 three.js 进行封装，实现一个简单的应用类，便于调用使用。
>

### World 接口

在 World 类中，我们定义了一个接口，用于调用 World 类的方法。
```js
// 1. Create an instance of the World app
const world = new World(container);

// 2. Render the scene
world.render();
```

### World 类

创建 World 类，并定义构造函数和 `render` 方法。

构造函数中，我们创建了场景、相机、渲染器等对象，并将渲染器添加到页面中。

`render` 方法中，我们调用渲染器的 `render` 方法，将场景和相机渲染到页面中。

```js
class World {
  // 1. Create an instance of the World app
  constructor(container) {}
  // 2. Render the scene
  render() {}
}

export { World };
```

World类中还需模块划分，这些模块分为两类：组件components和系统systems。组件是可以放置到场景中的任何东西，例如立方体、相机和场景本身，而系统是在组件或其他系统上运行的东西。


**目录如下所示**：

```text
components
├── camera.js
├── cube.js
└── scene.js
systems
├── renderer.js
└── Resizer.js
```

#### Systems: Renderer 模块

渲染器系统

:::code-group
```js {3} [systems/Renderer.js]
import { WebGLRenderer } from 'three';
function createRenderer() {
  const renderer = new WebGLRenderer();
  return renderer;
}
export { createRenderer };
```
:::

#### Components: Scene 模块

场景组件

:::code-group
```js {4,5} [components/scene.js]
import { Color, Scene } from 'three';

function createScene() {
  const scene = new Scene();
  scene.background = new Color('skyblue');
  return scene;
}

export { createScene };
```
:::

#### Components: Camera 模块

相机组件

:::code-group
```js {4-9,12} [components/camera.js]
import { PerspectiveCamera } from 'three';

function createCamera() {
  const camera = new PerspectiveCamera(
    35, // fov = Field Of View
    1, // aspect ratio (dummy value)
    0.1, // near clipping plane
    100, // far clipping plane
  );

  // move the camera back so we can view the scene
  camera.position.set(0, 0, 10);

  return camera;
}

export { createCamera };
```
:::

#### Components: Cube 模块

之后是立方体组件，它包括创建 **几何体**、 **材质** 和 **网格**。

有的时候可能会添加比这个更复杂的可见对象，在这种情况下，我们要将它们拆分为子模块，可能也会把 Geometry 和 Material 拆分为子模块。

:::code-group
```js {4-5,7-8,10-11} [components/cube.js]
import { BoxBufferGeometry, Mesh, MeshBasicMaterial } from 'three';

function createCube() {
  // create a geometry
  const geometry = new BoxBufferGeometry(2, 2, 2);

  // create a default (white) Basic material
  const material = new MeshBasicMaterial();

  // create a Mesh containing the geometry and material
  const cube = new Mesh(geometry, material);

  return cube;
}

export { createCube };
```
:::


#### Systems: Resizer 模块

最后，将为Resizer模块创建一个存根。这个与其他的有点不同，因为它是一个类而不是一个函数。

:::code-group
```js [systems/Resizer.js]
class Resizer {
  constructor() {}
}
export { Resizer };
```
:::

### 设置 World 类

#### 设置相机、渲染器和场景

将写好的模块进行导入到 `World.js` 中，设置**相机**、**场景**、**渲染器**。但这些内容需要私有，避免在主函数中访问。可以通过<span style="color: red">**模块作用域**</span>来声明创建类似*私有变量*的东西。

:::code-group
```js {10-12,17-19} [World.js]
// 模块导入
import { createCamera } from './components/camera.js';
import { createCube } from './components/cube.js';
import { createScene } from './components/scene.js';

import { createRenderer } from './systems/renderer.js';
import { Resizer } from './systems/Resizer.js';

// These variables are module-scoped: we cannot access them
// from outside the module
let camera;
let renderer;
let scene;

class World {
  constructor(container) {
    camera = createCamera();
    scene = createScene();
    renderer = createRenderer();
  }
```
:::

#### 将画布添加到容器中

当创建渲染器时，`<canvas>` 元素也会被创建并存储在 `renderer.domElement` 中。 下一步是将其添加到容器中。

:::code-group
```js {6} [World.js]
class World {
  constructor(container) {
    camera = createCamera();
    scene = createScene();
    renderer = createRenderer();
    container.append(renderer.domElement);
  }
```
:::


#### 渲染场景

::: code-group
```js [World.js]
render() {
  // draw a single frame
  renderer.render(scene, camera);
}
```
:::


#### 创建立方体

创建立方体并将其添加到场景中。

```js {6,7} [World.js]
constructor(container) {
  camera = createCamera();
  scene = createScene();
  renderer = createRenderer();
  container.append(renderer.domElement);
  const cube = createCube();
  scene.add(cube);
}
```

#### 设置 Resizer 类

Resizer 类会监听窗口大小，并更新相机和渲染器的尺寸，然后需要在 World.js 中实例化它。

::: tip
![perspective_frustum](./attachments/perspective_frustum.svg)
**平截头体**不会自动重新计算，因此当我们更改存储在 `camera.aspect`、`camera.fov`、`camera.near` 和 `camera.far`中的任何这些设置时，我们还需要更新平截头体，在**投影矩阵**中为来更新需要使用相机的 `.updateProjectionMatrix()` 方法。
:::

:::code-group
```js {4,6,8,10} [Resizer.js]
class Resizer {
  constructor(container, camera, renderer) {
    // Set the camera's aspect ratio
    camera.aspect = container.clientWidth / container.clientHeight;
    // update the camera's frustum
    camera.updateProjectionMatrix();
    // update the size of the renderer AND the canvas
    renderer.setSize(container.clientWidth, container.clientHeight);
    // set the pixel ratio (for mobile devices)
    renderer.setPixelRatio(window.devicePixelRatio);
  }
}
```
:::

### 完整代码

:::code-group
```js [World.js]
import { createCamera } from './components/camera.js';
import { createCube } from './components/cube.js';
import { createScene } from './components/scene.js';

import { createRenderer } from './systems/renderer.js';
import { Resizer } from './systems/Resizer.js';

// These variables are module-scoped: we cannot access them
// from outside the module
let camera;
let renderer;
let scene;

class World {
  constructor(container) {
    camera = createCamera();
    scene = createScene();
    renderer = createRenderer();
    container.append(renderer.domElement);

    const cube = createCube();

    scene.add(cube);

    const resizer = new Resizer(container, camera, renderer);
  }

  render() {
    // draw a single frame
    renderer.render(scene, camera);
  }
}

export { World };
```
:::