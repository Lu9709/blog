# 图片懒加载

> 图片懒加载通过延迟加载可视区域外的图片来减少初始加载时间
>

`<img>` 标签还有 `loading` 属性，该属性指示浏览器应当**如何加载该图像**。

* `eager`：立即加载图片，无论是否在可视区域。
* `lazy`：延迟加载图片，直到图片进入可视区域。

`<img>` 标签在HTML5还新增了一个 `decoding` 属性，该属性指示浏览器**如何解码该图像**。

* `sync`：同步解码图像，保证与其他内容一起显示。
* `async`：异步解码图像，加快显示其他内容。
* `auto`：默认模式，表示不偏好解码模式。由浏览器决定哪种方式更适合用户。


**实现原理**：
1. **不直接使用** `src` **属性**：
   图片的 `src` 属性一开始不设置图片地址，而是将图片地址存储在 `data-src` 或其他自定义属性中。

2. **监听滚动事件**：
   通过监听 `window.onscroll` 事件，判断图片是否进入了可视区域。

3. **加载图片**：
   当图片进入可视区域时，将 `data-src` 属性的值赋给 `src` 属性，触发图片加载。

4. **Intersection Observer API**：
  现代浏览器提供了更高效的Intersection Observer API，可以更方便地检测元素是否进入可视区域。


**实现方法**：

1. **传统scroll/throttle**：
::: tip
监听 `scroll` 事件，并使用 `throttle` 函数来节流，判断图片是否进入可视区域。
:::
```js
function loadImg(img) {
  img.src = img.dataset.src;
  img.onload = () => img.classList.add('loaded');
}
function check() {
  const imgNodes = document.querySelectorAll('img[data-src]');
  const H = window.innerHeight;
  imgNodes.forEach(img => {
    if (img.getBoundingClientRect().top < H + 100) loadImg(img);
  });
}
window.addEventListener('scroll', _.throttle(check, 200));
```
2. **getBoundingClientRect**：

:::tip Element.getBoundingClientRect()
该方法返回一个 [DOMRect](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，其提供了元素的大小及其相对视口的位置。
:::

:::code-group
```js [getBoundingClientRect 实现]
function isInViewPort(element) {
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const {
    top,
    right,
    bottom,
    left,
  } = element.getBoundingClientRect();
​
  return (
    top >= 0 &&
    left >= 0 &&
    right <= viewWidth &&
    bottom <= viewHeight
  );
}
```
:::

2. **IntersectionObserver**

:::tip Intersection Observer（交叉观察器）
配合监听元素的 `isIntersecting` 属性，判断元素是否在可视区内，能够实现比监听 `onscroll` 性能更佳的图片懒加载方案
:::
:::code-group
```js [IntersectionObserver 实现]
// 获取所有需要懒加载的图片
const images = document.querySelectorAll('img[data-src]');

// 创建 Intersection Observer 实例
const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.removeAttribute('data-src');
      observer.unobserve(img); // 取消观察，避免重复加载
    }
  });
});

// 监听每个图片
images.forEach(img => {
  observer.observe(img);
});
```
:::

**参考链接**：

> [Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)
>
> [img 元素 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img)
