### 两数之和

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    for(let i = 0; i < nums.length;i++ ){
        for(let j = i + 1;j < nums.length ;j++){
            if(target === nums[i] + nums[j]){
                return [i,j]
            }
        }
    }
}
```
[map方法](https://es6.ruanyifeng.com/#docs/set-map)

```js
var twoSum = function(nums, target) {
  let map = new Map();
  for (let i = 0; i < nums.length; i++) {
    let dif = target-nums[i]
    if (map.has(dif)) {
      return [map.get(dif), i]
    }
    map.set(nums[i], i);
  }
};
```
### 罗马字符数字转整数

```js
/**
 * @param {string} s
 * @return {number}
 */
let Num = {
        I:1,
        V:5,
        X:10,
        L:50,
        C:100,
        D:500,
        M:1000,
        IV:4,
        IX:9,
        XL:40,
        XC:90,
        CD:400,
        CM:900
    }
var romanToInt = function(s) {
    let sum = 0
    for(let i = 0;i < s.length ;i++){
        if(i < s.length && Num[s[i] + s[i+1]]){
            sum += Num [s[i] + s[i+1]]
            i += 1
        }else{
            sum += Num[s[i]]
        }
    }
    return sum
};
```
### 反转字符串

必须[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)**修改输入数组**、使用 O(1) 的额外空间

```js
/**
 Do not return anything, modify s in-place instead.
 */
function reverseString(s: string[]): void {
    s = s.reverse()
};
```
### 整数反转

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    let newX = x.toString()
    let sum
    if(newX[0]==='-'){
        sum = newX[1]*1
        for(let i = 2;i<newX.length;i++){
            sum += newX[i]*Math.pow(10,i-1)
        }
        sum*=-1
    }else{
        sum = newX[0]*1
        for(let i = 1; i<newX.length;i++){
            sum += newX[i]*Math.pow(10,i)
        }
    }
    if ( sum < - Math.pow(2, 31) || sum > Math.pow(2, 31) - 1){
        return 0
    }
    return sum
};
```
### 加一

给定一个由 **整数**组成的**非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

```js
function plusOne(digits: number[]): number[] {
    for(let i = digits.length -1;i>=0;i--){
        digits[i]+=1
        digits[i]%=10
        if(digits[i]!==0){
            return digits
        }
    }
    digits.unshift(1)
    return digits
};
```
### 旋转数组

给你一个数组，将数组中的元素向右轮转 k个位置，其中 k是非负数。

```ts
/**
 Do not return anything, modify nums in-place instead. Way One
 */
function rotate(nums: number[], k: number): void {
    for(let i:number =0;i<k;i++){
        nums.unshift(nums.pop())
    }
};
/**
 Do not return anything, modify nums in-place instead. Way Two 使用临时数组
 */
function rotate(nums: number[], k: number): void {
    let newNums:number []=[]
    let length = nums.length
    for(let i = 0;i<length;i++){
        newNums[i] = nums[i]
    }
    for(let i = 0;i<length;i++){
        nums[(i+k)%length] = newNums[i]
    }
};
```
### 存在重复元素

给你一个整数数组 nums 。如果任一值在数组中出现 **至少两次** ，返回 true ；如果数组中每个元素互不相同，返回 false 。

```ts
//方法一
function containsDuplicate(nums: number[]): boolean {
    let arr:number [] = [...new Set(nums)]
    return arr.length !== nums.length
};
//方法二
function containsDuplicate(nums: number[]): boolean {
    nums.sort((a,b)=>a-b)
    for(let i = 0;i<nums.length;i++){
        if(nums[i]===nums[i+1]) return true
    }
    return false
};
```
### 只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```ts
function singleNumber(nums: number[]): number {
    nums.sort((a,b)=>a-b)
    for(let i = 0;i<nums.length;i++){
        if(nums[i]===nums[i+1]){
            i++
        }else {
            return nums[i]
        }
    }
};
```
### 二分法查找

```ts
function search(nums: number[], target: number): number {
    let numsLength = nums.length
    if(!numsLength) return -1
    if(numsLength === 1){
        return nums[0] === target ? 0:-1
    }
    let start=0,end=numsLength - 1
    while(start<=end){
        let mid = Math.floor((start+end)/2) //取中位数d
        if(nums[mid] === target){
            return mid
        }else if (target > nums[mid]){ //目标数比中位数大,移动初始值start边界
            start = mid + 1
        }else {
            end = mid - 1 //目标数比中位数小,移动初始值end边界
        }
    }
    return -1
};
```
### 寻找数组的中心索引

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var pivotIndex = function(nums) {
    const total = nums.reduce((pre,cur)=>pre+=cur,0)
    let number = -1
    let left = 0
    for(let i=0;i<nums.length;i++){
        left += nums[i]
        console.log(left,'left',total-nums[i]-left)
        if(left === total + nums[i] - left){
            number = i
            break;
        }
    }
    return number
};
```

```ts
function pivotIndex(nums: number[]): number {
  let number = -1,sum=0
  const total = nums.reduce((pre,cur)=>pre+=cur,0)
  nums.some((cur,index)=>{
    sum+=cur
    if(sum === total + cur - sum){
      number = index
      return true
    }
  })
  return number
};
```
### 搜索插入位置

```ts
function searchInsert(nums: number[], target: number): number {
 let result:number
    nums.some((cur,index)=>{
        if(cur >=  target) {
            result = index
            return true
        }
    })
    return result ?? nums.length
};
```

```ts
function searchInsert(nums: number[], target: number): number {
    let result:number
    if(nums[nums.length-1] < target) {
        return nums.length
    }else {
        for(let i=0;i<nums.length;i++){
            if(nums[i] >= target){
                result = i
                break
            }
        }
    }
    return result
};
```
### 合并区间

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function (intervals) {
  const sortNums = intervals.sort((a, b) => a[0] - b[0])
  return sortNums.reduce((pre, cur) => {
      const arr = pre[pre.length - 1]
      if (arr && arr[1] >= cur[0]) {
        let left = arr[0]
        let right = arr[1] <= cur[1] ? cur[1] : arr[1]
        pre[pre.length - 1] = [left,right]
      } else {
          pre.push(cur)
      }
    return pre
  }, [])
};
```
### 删列造序

```js
/**
 * @param {string[]} strs
 * @return {number}
 */
var minDeletionSize = function(strs) {
    let number = 0
    const arr = strs[0].split('').map((item,index)=> strs.map(_item=> _item[index]))
    for(let item of arr) {
        for(let i=0;i<item.length-1;i++){
            if(item[i] > item[i+1]){
                number ++
                break;
            }
        }
    }
    return number
};
```
### 旋转矩阵

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    const arr = matrix.reverse()
    for(let i = 0;i<arr.length ;i++){
        for(let j = i;j<arr[i].length;j++){
            let temp = arr[i][j]
            arr[i][j] = arr[j][i]
            arr[j][i] = temp
        }
    }
    return arr
};
```
### 零矩阵

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
    let rowArr = [],columnArr = []
   matrix.forEach((item,index)=>{
       item.forEach((_item,_index)=>{
           if(_item ===0) {
               if(rowArr.indexOf(index) === -1) rowArr.push(index)
               if(columnArr.indexOf(_index) === -1) columnArr.push(_index)
           }
       })
   })
   rowArr.forEach(item=>{
       matrix[item] = matrix[item].map(item=>item = 0)
   })
   columnArr.forEach(item=>{
       for(let i =0;i<matrix.length;i++){
           matrix[i][item] = 0
       }
   })
    return matrix
};
```
### 最大三角形面积

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var largestTriangleArea = function(points) {
    let maxArea = 0

    const getArea = ([x1,y1],[x2,y2],[x3,y3]) => {
        const area =  (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2
        return area > 0 ? area : -1 * area
    }
    for(let i=0;i < points.length;i++){
        for(let j= i + 1;j < points.length;j++){
            for(let k = j + 1;k < points.length;k++){
                const areaInfo = getArea(points[i],points[j],points[k]);
                if(areaInfo >= maxArea) maxArea = areaInfo
            }
        }
    }
    return maxArea
};
```
### 最长公共前缀

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    for(let i=0;i<strs[0].length;i++){
        let s = strs[0][i]
        for(let j=1;j<strs.length;j++){
            if(strs[j][i] !== s) {
                return strs[0].slice(0,i)
            }
        }
    }
    return strs[0]
};
```
### 翻转字符串中的单词

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    return s.split(' ').filter(item=>item!=='').reverse().join(' ')
};
```
### 数组拆分 I

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
    const arr = nums.sort((a,b)=>a-b)
    let total = 0
    for(let i=0;i<arr.length;){
        total += arr[i]
        i+=2
    }
    return total
};
```
### 最长回文子串

通过遍历查找每个字符的左右边界且相等的情况下，返回边界值，如果边界的长度大于原先的边界则覆盖。但考虑到字符串的长度可能是奇数或者偶数，考虑中心点可能是1个或者2个。

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    const expandeAroundCenter = (s,left,right)=>{
        while(left >= 0 && right < s.length && s[left]===s[right]){
            left--
            right++
        }
        return [left+1,right-1]
    }
    let start=0,end=0
    for(let i=0;i<s.length;i++){
        const [left1,right1] = expandeAroundCenter(s,i,i)
        const [left2,right2] = expandeAroundCenter(s,i,i+1)
        if(right1-left1>end-start){
            end = right1
            start = left1
        }
        if(right2-left2>end-start){
            end = right2
            start = left2
        }
    }
    return s.slice(start,end+1)
}

```
### 杨辉三角 I

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
 let arr = [[1]]
    if(numRows===1){
        return arr
    } else if(numRows===2){
        arr.push([1,1])
        return arr
    } else {
        arr.push([1,1])
        for(let i=2;i<numRows;i++) {
            let x = [1]
            for(let j=0;j < arr[i-1].length - 1;j++){
                x.push(arr[i-1][j] + arr[i-1][j+1])
            }
            x.push(1)
            arr.push(x)
        }
        return arr
    }
}
```

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
    let total = []
    for(let i = 0;i < numRows;i++){
        let arr = new Array(i+1).fill(1)
        for(let j = 1;j < arr.length - 1;j++){
            arr[j] = total[i-1][j-1] + total[i-1][j]
        }
        total.push(arr)
    }
    return total
};
```

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
    let total = []
    const getRow = (index) =>{
        let row = new Array(index).fill(0)
        row[0] = 1
        for(let i=1;i<=index;i++){
            row[i] = row[i-1] * (index - i + 1) / i
        }
        return row
    }
    for(let i = 0;i < numRows;i++){
        const row = getRow(i)
        total.push(row)
    }
    return total
};
```
### 杨辉三角 II

返回第n行的数组

```js
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    let total = []
    for(let i=0;i<rowIndex+1;i++){
        let arr = new Array(i+1).fill(1)
        for(let j = 1;j < arr.length - 1;j++){
            arr[j] = total[i-1][j-1] + total[i-1][j]
        }
        total.push(arr)
    }
    return total[rowIndex]
};
```

```js
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    let rowArr = new Array(rowIndex + 1).fill(0)
    rowArr[0] = 1
    for(let i=1;i <= rowIndex; i++){
        rowArr[i] = rowArr[i - 1] * (rowIndex - i + 1) / i
    }
    return rowArr
};
```
### 反转字符串中的单词 III

* **输入：**s = "Let's take LeetCode contest"
* **输出：**"s'teL ekat edoCteeL tsetnoc"

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    const arr = s.split(' ')
    for(let i=0;i<arr.length;i++){
        arr[i] = arr[i].split('').reverse().join('')
    }
    return arr.join(' ')
};
```
### 最大连续1的个数

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function(nums) {
    const arr = nums.join('').split(0)
    let max = 0
    for(let i=0;i<arr.length;i++){
        const length = arr[i].length
        max = length > max ? length : max
    }
    return max
};
```

```
const findMaxConsecutiveOnes = (nums) => {
  let maxCount=0,count=0
  for(let i = 0;i < nums.length;i++){
    if(nums[i] === 1){
       count++
    } else {
      maxCount = Math.max(maxCount,count)
      count = 0
    }
  }
  return Math.max(maxCount,count)
}
```
### 移除元素

给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

```js
const removeElement = (nums,val) => {
  let i = 0
  nums.forEach((item,index)=>{if(item !==val) nums[i++] = nums[index]})
  return i
}
```

```js
const removeElement = (nums,val) => {
    let left=0,right= nums.length
    while(left < right){
      if(nums[left] === val){
        nums[left] = nums[right-1]
        right--
      } else {
        left++
      }
    }
   return left
}
```
### 移动零

快指针遇到非零数，则和慢指针指向的零交换位置。

```js
const moveZeros = (nums) =>{
  let slow = 0
  for(let fast = 0;fast < nums.length;fast++){
    if(nums[fast]){
      let temp = nums[slow]
      nums[slow] = nums[fast]
      nums[fast] = temp
      slow++
    }
  }
  return nums
}
```
### 实现strStr()

给你两个字符串`haystack`和`needle`，请你在`haystack`字符串中找出`needle`字符串的第一个匹配项的下标（下标从 0 开始）。如果`needle`不是`haystack`的一部分，则返回  -1 。

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    for (let i=0;i<haystack.length;i++) {
        const needleLength = needle.length
        const haystackLength = haystack.length
        if (haystackLength >= needleLength + i) {
            const copy = haystack.slice(i,needleLength + i)
            if(copy === needle) {
                return i
            }
        }
    }
    return -1
};
```
### 寻找旋转排序数组中的最小值

必须使用`O(log n)`的时间复杂度

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    if(nums.length === 1) return nums[0]
    let l=0,r = nums.length - 1
    while(l<r) {
        let mid = Math.floor((l+r)/2)
        if(nums[mid]>nums[r]) {
            l = mid + 1;
        } else {
         r = mid
        }
    }
    return nums[l]
};
```
### 树结构树节点查找本层深度

```js
/**
 * 查看树中Object的嵌套深度
 * @param {number} id
 * @return {number}
 */
function  getTreeMaxFloor(findId) {
  let toggle = false
  let max = 1
  let result = 1
  const callBack = (findId, data) => {
    for (let i = 0; i < data.length; i++) {
      const { id, type, children } = data[i]
      if (type === 'Object') {
        if (findId !== id && children.length > 0) {
          max += 1
          callBack(findId, children)
        } else if (findId === id) {
          toggle = true
          result = max
        }
      }
    }
    max = toggle ? result : 1
  }
  callBack(findId, this.treeData)
  return result
}
```
### **K 件物品的最大和**

```js
/**
 * @param {number} numOnes
 * @param {number} numZeros
 * @param {number} numNegOnes
 * @param {number} k
 * @return {number}
 */
var kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {
    return numOnes > k
    ? k
    : numOnes + numZeros < k ? 2 * numOnes + numZeros - k : numOnes
};
```
### 矩阵中的和

```js
/**
 * @param {number[][]} nums
 * @return {number}
 */
var matrixSum = function(nums, x = 0) {
    let total = x
    let curMax = 0
    for (let i = 0; i < nums.length; i++){
        const numsList = nums[i]
        const { max, maxIndex } = getMaxNumber(numsList)
        numsList.splice(maxIndex, 1)
        if (max > curMax) curMax = max
    }
    total += curMax
    return nums[0].length === 0 ? total : matrixSum(nums, total)
};

var getMaxNumber = (arr) => {
    let max = 0
    let maxIndex = -1
    for (let i = 0; i < arr.length; i++) {
        const cur = arr[i]
        if (max < cur) {
            max = cur
            maxIndex = i
        }
    }
    return { max, maxIndex }
}
```
### 拆分成最多数目的正偶数之和

```js
function maximumEvenSplit(finalSum: number): number[] {
  if (finalSum % 2 !== 0) return []
  let arr: number[] = []
  for (let i = 2; i <= finalSum; i+=2) {
    arr.push(i)
    finalSum -= i
  }
  arr[arr.length - 1] += finalSum
  return arr
}
```
### 两数之和 II - 输入有序数组

原理：通过双向双指针，因为原数组是经过排序的，时间复杂度O(n)

```js
function twoSum(numbers: number[], target: number): number[] {
    let l = 0, r = numbers.length - 1
    while (numbers[l] + numbers[r] !== target) {
        numbers[l] + numbers[r] < target ? l++ : r--
    }
    return [l+1, r+1]
};
```
###

### 两个数字的最大乘积

给定一个正整数 `n`。
返回 **任意两位数字** 相乘所得的 **最大** 乘积。

注意：如果某个数字在 `n` 中出现多次，你可以多次使用该数字。

```ts
function maxProduct(n: number): number {
    const str = n.toString()
    let max = 0
    for(let i = 0; i < str.length; i++) {
        for (let j = i + 1; j < str.length; j++) {
            let result = Number(str[i]) * Number(str[j])
            if (result > max) {
                max = result
            }
        }
    }
    return max
};
```

### 字符串压缩

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串`aabcccccaaa`会变为`a2b1c5a3`。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

```ts
function compressString(S: string): string {
    if (!S) return ''
    let result = ''
    let count = 1
    let currentStr = S[0]
    for (let i = 1; i < S.length; i++) {
        if (currentStr === S[i]) {
            count++
        } else {
            result += currentStr + count
            currentStr = S[i]
            count = 1
        }
    }
    result += currentStr + count
    return result.length >= S.length ? S : result
};
```


### 两数相加

给你两个**非空**的链表，表示两个非负的整数。它们每位数字都是按照**逆序**的方式存储的，并且每个节点只能存储**一位**数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    let head = null, tail = null;
    let carry = 0
    while(l1 || l2) {
        const n1 = l1 ? l1.val : 0
        const n2 = l2 ? l2.val : 0
        const sum = n1 + n2 + carry
        if (!head) {
            head = tail = new ListNode(sum % 10)
        } else {
            tail.next = new ListNode(sum % 10)
            tail = tail.next
        }
        carry = Math.floor(sum / 10)
        if (l1) {
            l1 = l1.next
        }
        if (l2) {
            l2 = l2.next
        }
    }
    if (carry > 0) {
        tail.next = new ListNode(carry)
    }
    return head

};

```


### 扁平化嵌套数组

请你编写一个函数，它接收一个 **多维数组** `arr` 和它的深度 `n` ，并返回该数组的 **扁平化** 后的结果。

多维数组 是一种包含整数或其他 **多维数组** 的递归数据结构。

::: code-group
```js [递归]
/**
 * @param {any[]} arr
 * @param {number} depth
 * @return {any[]}
 */
var flat = function (arr, n) {
    let res = [];
    const flattening = (nums, l) => {
      for (const num of nums) {
        if (Array.isArray(num) && l > 0) {
          flattening(num, l - 1);
        } else {
          res.push(num);
        }
      }
    }

    flattening(arr, n);
    return res;
};
```
```js [迭代堆栈]
/**
 * @param {any[]} arr
 * @param {number} depth
 * @return {any[]}
 */
var flat = function (arr, n) {
    const stack = [...arr.map((item) => [item, n])];
    const res = [];

    while (stack.length > 0) {
        const [item, depth] = stack.pop();
        if (Array.isArray(item) && depth > 0) {
            // 降低深度后重新推回堆栈
            stack.push(...item.map((el) => [el, depth - 1]));
        } else {
            res.push(item);
        }
    }

    return res.reverse();
};
```
:::


### 2的幂次

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    // Math.log2() 返回一个数的对数，以 2 为底
    // Number.isInteger() 确定一个数字是否为整数
    return Number.isInteger(Math.log2(n))
};
```

### 检查是否是类的对象实例

::: code-group
```js [普通实现]
var checkIfInstanceOf = function (obj, classFunction) {
    // 数据兼容性会有问题
    if (obj === null || obj === undefined || !(obj instanceof classFunction)) return false
    // 将基本数据类型转为引用对象
    return Object(obj) instanceof classFunction
}

```
```js [递归实现]
var checkIfInstanceOf = function (obj, classFunction) {
  if (
    obj === null ||
    obj === undefined ||
    classFunction === null ||
    classFunction === undefined
  )
    return false;
  return (
    obj.__proto__ === classFunction.prototype ||
    checkIfInstanceOf(obj.__proto__, classFunction)
  );
};
```
:::


### 数组原型对象的最后一个元素

:::code-group
```js [三元运算符]
/**
 * @return {null|boolean|number|string|Array|Object}
 */
Array.prototype.last = function() {
    return this.length === 0 ? -1 : this[this.length - 1]
};

/**
 * const arr = [1, 2, 3];
 * arr.last(); // 3
 */
```
```js [合并运算符运算符]
Array.prototype.last = function() {
  return this[this.length - 1] ?? -1;
}
```
:::

### 只允许调用一次的函数

:::code-group
```js [rest方法]
var once = function(fn) {
  let hasBeenCalled = false;
  return function(...args){
    if (hasBeenCalled) {
      return undefined;
    } else {
      hasBeenCalled = true;
      return fn.call(undefined, ...args);
    }
  }
};
```
```js [绑定上下文]
var once = function(fn) {
  let hasBeenCalled = false;
  return function(...args){
    if (!hasBeenCalled) {
      hasBeenCalled = true;
      return fn.apply(this, args);
    }
  }
};
```
:::

### 睡眠函数

请你编写一个异步函数，它接收一个正整数参数 `millis` ，并休眠 `millis` 毫秒。要求此函数可以解析任何值。

请注意，实际睡眠持续时间与 `millis` 之间的微小偏差是可以接受的。

```js
/**
 * @param {number} millis
 * @return {Promise}
 */
async function sleep(millis) {
  return new Promise((resolve) => { 
    setTimeout(resolve, millis)
  })
}
/** 
 * let t = Date.now()
 * sleep(100).then(() => console.log(Date.now() - t)) // 100
 */
```

### 数组归约运算

实现一个类似 `reduce` 的方法，传入一个数组和一个函数，返回一个值。
:::code-group
```js [for of]
function reduce(arr, fn, initial) {
    let result = initial;
    for (const value of arr) {
        result = fn(result, value)
    }
    return result;
}
```
```js [for in]
function reduce(arr, fn, initial) {
    let result = initial;
    for (const index in arr) {
        result = fn(result, arr[index])
    }
    return result;
}
```
```js [forEach]
function reduce(arr, fn, initial) {
    let result = initial;
    arr.forEach(value => {
        result = fn(result, value)
    })
    return result;
}
```
:::

### 复合函数

请你编写一个函数，它接收一个函数数组 `[f1, f2, f3，…， fn]` ，并返回一个新的函数 `fn` ，它是函数数组的 **复合函数** 。

`[f(x)， g(x)， h(x)]` 的 复合函数 为 `fn(x) = f(g(h(x)))` 。

一个空函数列表的 **复合函数** 是 **恒等函数** `f(x) = x` 。

你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。

::: code-group
```js  [for loop]
var compose = function (functions) {
  return function (x) {
    if (functions.length === 0) return x;
    let input = x;

    for (let i = functions.length - 1; i >= 0; i--) {
      const currFunc = functions[i];

      input = currFunc(input);
    }

    return input;
  };
};

```
```js [reduceRight]
var compose = function(functions) {
    return x => functions.reduceRight((acc, f) => f(acc), x);
};
```
:::

### 判断对象是否为空

:::code-group
```js [Object.keys]
/**
 * @param {Object|Array} obj
 * @return {boolean}
 */
var isEmpty = function(obj) {
    return Object.keys(obj).length === 0
};
```
```js [JSON.stringify]
/**
 * @param {Object|Array} obj
 * @return {boolean}
 */
var isEmpty = function(obj) {
    return JSON.stringify(obj).length === 2
}
```
```js [for...in]
/**
 * @param {Object|Array} obj
 * @return {boolean}
 */
var isEmpty = function(obj) {
    for (const _ in obj) return false;
    return true;
};
```
:::


### 过滤数组中的元素

给定一个整数数组 `arr` 和一个过滤函数 `fn`，并返回一个过滤后的数组 `filteredArr` 。

`fn` 函数接受一个或两个参数：

* `arr[i]` - `arr` 中的数字
* `i` - `arr[i]` 的索引

::: code-group
```js [for in]
var filter = function(arr, fn) {
    const newArr = [];
    for (const stringIndex in arr) {
        const i = Number(stringIndex);
        if (fn(arr[i], i)) {
            newArr.push(arr[i]);
        }
    }
    return newArr;
};
```
```js [将值推入新数组]
var filter = function(arr, fn) {
    const newArr = [];
    for (let i = 0; i < arr.length; ++i) {
        if (fn(arr[i], i)) {
            newArr.push(arr[i]);
        }
    }
    return newArr;
};
```
:::


### 转换数组中的每个元素

编写一个函数，这个函数接收一个整数数组 `arr` 和一个映射函数  `fn` ，通过该映射函数返回一个新的数组。

返回数组的创建语句应为 `returnedArray[i] = fn(arr[i], i)` 。

:::code-group
```js [for in]
var map = function(arr, fn) {
    const newArr = new Array(arr.length);
    for (const stringIndex in arr) {
        const i = Number(stringIndex);
        newArr[i] = fn(arr[i], Number(i));
    }
    return newArr;
};
```
``` js [for loop 预先分配内存]
var map = function(arr, fn) {
    const newArr = new Array(arr.length);
    for (let i = 0; i < arr.length; ++i) {
        newArr[i] = fn(arr[i], i);
    }
    return newArr;
};
```
:::

### 删除字符串中的所有相临重复项

```js
var removeDuplicates = function(s) {
    // 利用栈 的数据结构 若遇到相邻重复项 则弹出栈顶元素
    let stack = [];
    for (const value of s) {
        if (s.length && value === stack[stack.length - 1]) {
            stack.pop();
        } else {
            stack.push(value);
        }
    }
    return stack.join('');
}
```

### 合并两个有序数组

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, nums1.length - m, ...nums2)
    nums1.sort((a, b) => a - b)
};
```

### 数组构造树结构

::: code-group
```js [find]
function listToTree(data) {
  const tree = []
  data.forEach((item) => {
    const parent = data.find((node) => node.id === item.parentId)
    if (parent) {
      parent.children = parent.children || []
      parent.children.push(item)
    } else {
      tree.push(item)
    }
  })
  return tree
}
```
```js [hash表]
function listToTree(data) {
  const tree = []
  const map = {}
  // 先将数组转换为 hash 表
  data.forEach((item) => {
    map[item.id] = { ...item }
  })
  data.forEach((item) => {
    const { parentId, id } = item
    if (parentId) {
        const parent = map[parentId]
        if (parent) {
          parent.children = parent.children || []
          parent.children.push(map[id])
        }
    } else {
      tree.push(map[id])
    }
  })
  return tree
}
```
```js [递归]
function recursiveToTree(data, root) {
  function loop(key) {
    const arr = [];
    data.forEach((item) => {
      if (item.parentId === key) {
        item.children = loop(item.id);
        arr.push(item);
      }
    });
    return arr;
  }
  return loop(root);
}
```
:::


### 相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
    const map = new Map();
    let curA = headA;
    while (curA !== null) {
        map.set(curA, true);
        curA = curA.next;
    }
    let curB = headB;
    while (curB !== null) {
        if (map.has(curB)) {
            return curB;
        }
        curB = curB.next;
    }
    return null;
}
```